<!DOCTYPE html>
<html>
	<head>
		<link href='http://fonts.googleapis.com/css?family=Slabo+27px' rel='stylesheet' type='text/css'>
		<meta charset="utf-8">
		<title>Grund forest-bump</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: 'Slabo 27px', serif;

				font-size: 30px;
				text-shadow: -2px 0 black, 0 2px black,
     			 2px 0 black, 0 -2px black;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);
				filter: blur(0.5px);
				-webkit-filter: blur(0.5px);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #9999FF;
				text-align: center;

				cursor: pointer;

			}



		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/PointerLockControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/JSONLoader.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/sound.js"></script>

		<div id="blocker">

			<div id="instructions">
				<span style="font-size:60px">Forest-Bump</span>
				<br /> <br /> 
				Experience a walk through a surreal 3D landscape
				<br /> <br /> 	
				Instructions: (W, A, S, D = Move, MOUSE = Look around)
			</div>

		</div>

		<script>
			
			
			//********* Variables ************//
			var camera, scene, renderer;
			var geometry, material, mesh, plane;
			var controls, stats;
			var width; // for size of plane and blocking function "update"

			var objects = [];

			var raycaster;

			var controlsEnabled = false;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			//calls css-code
			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );

			//Variabler f√∂r ljuset
			var ficklampa, targetObject, sound1;
			
			
			//********* Varify support of webGL ************//
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			
			
			//********* Run Program ************//
			init();
			animate();

			

			//********* Pointer Locker ************//
			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if ( havePointerLock ) {

				var element = document.body;

				var pointerlockchange = function ( event ) {

					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						controlsEnabled = true;
						controls.enabled = true;

						blocker.style.display = 'none';

					} else {

						controls.enabled = false;

						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';

						instructions.style.display = '';

					}

				}

				var pointerlockerror = function ( event ) {

					instructions.style.display = '';

				}

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {

					instructions.style.display = 'none';

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if ( /Firefox/i.test( navigator.userAgent ) ) {

						var fullscreenchange = function ( event ) {

							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

								element.requestPointerLock();
							}

						}

						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false );

			} else {

				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}
			
			
			//********* Setting up code for three.js ************//
			function init() 
			{

				//------ Initialize camera and scene and controls ------//
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 2500 );
				scene = new THREE.Scene();
				camera.position.set(0,-6,0);

				// Fog
				//scene.fog = new THREE.Fog(0xffffff, 0.02, 3500);


				controls = new THREE.PointerLockControls( camera );
				scene.add( controls.getObject() );



				//------ handling keys ------//
				var onKeyDown = function ( event ) 
				{

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true; break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

					}

				};

				var onKeyUp = function ( event ) 
				{

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );


				//------ Creating world ------//

				// --- PLANE AND TEXTURE ------
				
 				width = 500; // use this variable for size of plane and skybox and for function "update"

		        // -------- GROUND (bumpplane) ---------
		        // use variable width for size of plane and skybox
		        									//(width, length, segments width, segments length) must be ints!
		        var geometry = new THREE.PlaneBufferGeometry( width, width, Math.floor(width/3.0), Math.floor(width/3.0));
		        // **************************************************
		        // ** **Use PlaneBufferGeomentry for not using too much memory *****
		        // http://stackoverflow.com/questions/27198525/three-js-what-is-planebuffergeometry
				// the vertices are located in PlaneBufferGeometry are located in PlaneBufferGeometry.attributes.position instead of PlaneGeometry.vertices
				// https://github.com/mrdoob/three.js/blob/a72347515fa34e892f7a9bfa66a34fdc0df55954/src/extras/geometries/PlaneBufferGeometry.js
				// http://threejs.org/docs/#Reference/Core/BufferAttribute
				// *************************************************

				for(var i = 0; i < geometry.attributes.position.length; i++) 
				{
	                //geometry.vertices[i].z = Math.random() * 1.5;
                	geometry.attributes.position.setZ ( i, Math.random() * -1.5 );
	            }

		        var material = new THREE.MeshLambertMaterial(
		        {
	            	color:0xBEC2D1, // light gray/blue
	            	shading: THREE.SmoothShading
		        } );

		        material.side = THREE.DoubleSide;

	            bumpplane = new THREE.Mesh(geometry, material);

	            bumpplane.rotation.x = 90 * (Math.PI / 180);
	            //mesh.position.y = 10;
				
				scene.add(bumpplane);
				bumpplane.receiveShadow = true;
				bumpplane.castShadow = true;
				bumpplane.position.y -= 0.5;

		        // ------ SKYBOX --------
				// code from http://stemkoski.github.io/Three.js/Skybox.html
				var imagePrefix = "images/starfield-";
				var directions  = ["right", "left", "top", "down", "front", "back"];
				var imageSuffix = ".jpg";
				var skyGeometry = new THREE.BoxGeometry( width, width, width );	
				
				// create array for images to skybox
				var materialArray = [];
				for (var i = 0; i < 6; i++)
					materialArray.push( new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
						side: THREE.BackSide
					}));
				var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
				
				// testing variable for test without textures
				//var himmelmaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
				scene.add( skyBox );
				

				 //******* Load a tree object ****
                //---Load Model----

                //Skapa JSON-inladdare
                var jsonLoader = new THREE.JSONLoader();
                //Ladda in modeller
                jsonLoader.load( "./3Dmodels/treeOut.js", addModelToScene );

/*
                  // create a new material
              	var materials = new THREE.MeshLambertMaterial({
                	map: THREE.ImageUtils.loadTexture("./textures/bark.jpg"),  // specify and load the texture
                	colorAmbient: [0.480000026226044, 0.480000026226044, 0.480000026226044],
                	colorDiffuse: [0.480000026226044, 0.480000026226044, 0.480000026226044],
                	colorSpecular: [0.8999999761581421, 0.8999999761581421, 0.8999999761581421]
              	});

   
*/

                function addModelToScene( geometry, materials ) //materials not needed
		        {				
		               //create material, load a texturemap
		               var material = new THREE.MeshLambertMaterial({
		               			 map: THREE.ImageUtils.loadTexture("./textures/tilebark_small_repeated_light.jpg")
		             	 });


		               //for loop to create each tree
                	for ( var i = 0; i < 500; i ++ ) 
                	
{  
	                    model = new THREE.Mesh( geometry, material );
	                    
	                    var size = Math.random()+0.8;
	                    model.scale.set(size, size, size);
	                    model.position.x = ( Math.random() - 0.5 ) * 500;
	                    model.position.y = 0;
	                    model.position.z = ( Math.random() - 0.5 ) * 500;
	                    model.castShadow = true;
	                    model.receiveShadow = true;
	                    model.rotation.y = Math.random()*2*(Math.PI);
	                   	scene.add(model);
	                    
                    
                	}

            	}


            // MOON

            	// load texture file
				var moonTex = THREE.ImageUtils.loadTexture("textures/moon.jpg");
				// set repeating image all over the object
				moonTex.wrapS = moonTex.wrapT = THREE.RepeatWrapping;
				// set how small the image should be, how many times it should repeat
				moonTex.repeat.set( 10, 10 );
				// create a material with our texture to add on the object
				var moonMat = new THREE.MeshPhongMaterial( { map: moonTex } );
				// make sure the texture is applied to both sides
				moonMat.side = THREE.DoubleSide;

            	var moon = new THREE.SphereGeometry( 30, 30, 50 );
            	//var moonMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0xffffff, shininess: 20 });
				var sphere = new THREE.Mesh( moon, moonMat);

				// position for 1000 size skybox: ( 400, 300, 10), y must be set to negative
				sphere.position.set( (width/2)-(width/10) , -((width/2)-2*(width/10)) , width/100);

				scene.add(sphere);
				console.log("sphere.position.x = ", sphere.position.x);
				console.log("sphere.position.y = ", sphere.position.y);
				console.log("sphere.position.z = ", sphere.position.z);


				//------ Creating light ------//

				//random bl√•tt ljus som man kan ha som kul grej att leta efter
				var light1 = new THREE.PointLight( 0x0000ff, 1, 30);
				light1.position.x = ( Math.random() - 0.5 ) * 200;
				light1.position.y = 2;
				light1.position.z = ( Math.random() - 0.5 ) * 200;
				//scene.add(new THREE.PointLightHelper(light1, 3))
				scene.add( light1 );

				//bl√• boll som √§r vid det bl√• ljuset
				var sphereGeo = new THREE.SphereGeometry(1, 10, 10);
				var sphereMat = new THREE.MeshPhongMaterial({ color: 0x0000ff, specular: 0xffffff, shininess: 20 });
				var blueSphere = new THREE.Mesh(sphereGeo, sphereMat);
				blueSphere.position.x = light1.position.x;
				blueSphere.position.y = light1.position.y;
				blueSphere.position.z = light1.position.z;
				scene.add(blueSphere);

				//ljus som spelas vid bollen
				sound1 = new Sound( [ './music/hejhej.mp3', './music/hejhej.mp3' ], 60, 1 );
				sound1.position.copy( blueSphere.position );
				sound1.play();

				//Spotlight (ficklampa)
				ficklampa = new THREE.SpotLight(0xffffff, 2, 200, Math.PI/4, 2);
				
				ficklampa.castShadow = true;
				ficklampa.shadowCameraNear = 0.01;
				ficklampa.shadowCameraFov = 100;
				
				scene.add(ficklampa);

				//object som ficklampan pekar p√•
				targetObject = new THREE.Object3D();

				targetObject.position.x = controls.getObject().position.x;
				targetObject.position.y = controls.getObject().position.y;
				targetObject.position.z = controls.getObject().position.z - 50;
				scene.add(targetObject);


				//Ambient light
				var lightamb = new THREE.AmbientLight( 0x101010 ); // soft white light
				scene.add( lightamb ); 

				//------ Initialize render ------//
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapEnabled = true;
				document.body.appendChild( renderer.domElement );
				
				//------ Initialize the stats ------//
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				blocker.appendChild( stats.domElement );
			
				//calling resize function onWindowResize()
				window.addEventListener( 'resize', onWindowResize, false );
				
			}
			
			
			
			
			//********* Handling window resize************//

			function onWindowResize() 
			{

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			
			//********* Animating scene ************//

			function animate() 
			{

				requestAnimationFrame( animate );

				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					var intersections = raycaster.intersectObjects( objects );

					var isOnObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( moveForward ) velocity.z -= 80.0 * delta;
					if ( moveBackward ) velocity.z += 80.0 * delta;

					if ( moveLeft ) velocity.x -= 80.0 * delta;
					if ( moveRight ) velocity.x += 80.0 * delta;

					if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y );

						canJump = true;
					}

					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

						canJump = true;

					}

					prevTime = time;

				}

				//uppdatering av ficklampans postition, rotation
				var displacement = new THREE.Vector3(5, 5, -1);
				displacement.applyQuaternion(controls.getObject().quaternion);

				ficklampa.position.x = controls.getObject().position.x - displacement.x;

				ficklampa.position.y = controls.getObject().position.y - displacement.y;
				ficklampa.position.z = controls.getObject().position.z - displacement.z;

				var displacement2 = new THREE.Vector3(0, 0, 50);
				displacement2.applyQuaternion(controls.getObject().quaternion);

				targetObject.position.x = controls.getObject().position.x - displacement2.x;

				targetObject.position.y = controls.getObject().position.y - displacement2.y;
				targetObject.position.z = controls.getObject().position.z - displacement2.z;


				ficklampa.target = targetObject;

				sound1.update( controls.getObject() );
				
				// update and render scene 
				stats.update();
				updatePosition(camera.position);
				renderer.render( scene, camera );

			}

			
			//********* FUNCTION for using the camera position to change things ************//
			function updatePosition(position) 
			{
				// get the camera position from PointerLock
				var pos = controls.getObject().position;


				//console.log("pos.x: ", pos.x);
				//console.log("pos.z: ", pos.z);

				
				// Blocks camera to not go outside skybox
				// use variable width for size of plane and skybox
				//if ( pos.x > 249 || pos.z > 249 || pos.x < -249 || pos.z < -249)
	     		if ( pos.x > (width/2)-20 || pos.z > (width/2)-20 || pos.x < -(width/2)+20 || pos.z < -(width/2)+20)
				{
					console.log("FAN VAD NAJS");
					controls.getObject().position.set( 0, 0, 0 );
				}
			};

		</script>
	</body>
</html>